https://www.jianshu.com/p/eb63d31ad638
汇编指令:用符号表示的指令
汇编语言:汇编指令的集合

转换(预处理):高级语言之间的翻译 fortran->ada
编译:高级语言->汇编语言->机器语言
汇编:汇编语言->机器语言
交叉汇编:将一个汇编语言程序汇编成为能够在另一机器上运行的机器指令
反汇编:机器语言->汇编语言
反编译:汇编语言->高级语言
正则表达式:x:匹配字符x
		   .:匹配除'\n'以外的任意字符
		   [x-zA]:匹配括号内出现的所有字符 x-z按照字母表顺序规定范围
		   [^xyz]:匹配除括号内出现的字符以外的所有字符
		   r*:星闭包(克林闭包)出现0次多次
		   r+:正闭包,出现1次多次
		   r|s:并
		   rs:连接
		   ^r:以开头
		   r$:以结尾
		   r{n}:n次幂
		   r{m,n}:m到n次幂
		   r{m,}:大于n次幂
		  

编译器和解释器:1:先翻译后执行
			   2:边翻译边执行
			   主要区别:运行程序时的控制权在解释器而不是在目标程序
			   特点:编译器:工作效率高,时间快,空间省;交互性与动态性差,可移植性差
					解释器:工作效率低,时间慢,空间费;交互性动态性好,可移植性好
			   编译器的工作原理与基本组成:0:通用程序设计语言的主要成分:声明+操作=完整定义
										  1:以过程为基本结构的程序设计语言的组成:声明性语句:提供操作对象的性质,如数据类型,值,作用域等;
																				 操作性语句:确定操作的计算次序,完成设计操作
																				 过程定义:过程头+过程体
										  2:以阶段划分编译器:源程序->词法分析->语法分析->语义分析->中间代码生成->代码优化->目标代码生成->目标代码生成-
															 符号表管理和出错处理贯穿编译器工作的各个阶段
										  3:编译器各阶段工作:1:词法分析:输入是源程序,输出是识别出的记号流,目的是识别单词,至少分为以下几类:
																		关键字(保留字),标识符,字面量,特殊符号
															 2:语法分析:输入时词法分析器返回的记号流,输出是语法树,目的是得到语言结构并以树的形式表示,对于
																		声明式语句,进行符号表的查填,对于可执行语句,检查结构合理的表达式运算是否有意义
															 3:语义分析:根据语义规则对语法树种的语法单元进行静态语义检查,如类型检查和转换等,目的在于保证语法正确的结构在语义分析上也是合法的
															 4:中间代码生成(可选):生成一种既接近目标语言,又与具体机器无关的标识,便于代码优化与代码生成
																(到目前为止,编译器与解释器可以一致)
															 5:中间代码优化(可选):局部优化,循环优化,全局优化等,优化实际上是一个等价变换,变换前后的指令序列完成同样的功能,但在占用空间上和程序执行时间上都更省,更有效
															 6:目标代码生成:不同形式的目标代码:汇编语言形式,可重定位二进制代码形式,内存形式(load-and-go)
															 7:符号表管理:合理组织符号,便于各阶段查找/填写等
															 8:出错处理:动态错误:源程序中的逻辑错误,发生在程序运行的时候,也成为动态语义错误
																		静态错误:语法错误:有关语言结构上的错误:如单词拼写错误,表达式缺少操作数,begi和nend不匹配
																				 静态语义错误:分析源程序时可以发现语言意义上的错误,如假发的两个操作数一个是整形变量,一个是数组名
										  4:编译器的分析/综合模式:逻辑上把编译器分为分析部分和综合部分:1:分析(前段):语言结构和意义的分析;从词法分析到中间代码生成各阶段的工作
																									   2:综合(后端):语言意义处理:从中间代码生成到目标代码生成的各阶段的工作
																									   3:编译器和解释器的区别往往是在形成中间代码之后开始的
										  5:编译器扫描的遍数:每个阶段将程序完整分析一遍的工作模式成为一遍扫描,将中间代码表示完整分析一遍也称作一遍扫描

词法分析:1:概念:1记号,模式与单词:单词的分类:关键字(保留字),标识符,字面量,特殊符号
								 模式(pattern):产生/识别单词的规则
								 记号(token):按照某个模式(规则)识别出的一组元素
								 单词(lexeme):被识别出的元素的值(字符串本身),也成为词值
				2:词法分析器:作用:1:识别记号并交给语法分析器(根据模式识别记号)
								  2:过滤源程序中无用成分如注释,空格,回车等
								  3:处理与具体平台有关的输入(如文件结束符的不同表示)
								  4:调用符号表管理器和出错处理器,进行相关处理
							 工作方式:1:单独一遍扫描
									  2:作为语法分析器的子程序
									  3:并行方式
		 2:模式的形式化描述1:字符串与语言:语言L是有限字母表σΣ上有限长度字符串的集合
										  定义中强调两个有限因为计算甲的表示能力有限
			Εε							  1:字母表是有限的
										  2:字符串的长度是有限的
										  字符串与字符串集合相关的概念与运算入前缀后缀子串子序列等,字符串的并,连接,交,差,闭包等
						   2:正规式与正规集:令Σ是一个有限字母表,则Σ上的正规式及其表示的集合递归定义如下
											1:ε是正规式,表示结合L(ε)={ε}
											2:若a是Σ上的字符,则a是正规式,表示集合L(a)={a}
											3:若正规式r和s分别表示集合L(r)和L(s)则:
												a:r|s是正规式,表示集合L(r)UL(s)
												b:rs是正规式表示集合L(r)L(s)
												c:r*是正规式,表示集合(L(r))*
												d:(r)是正规式,表示的集合仍然是L(r)括弧用来改变运算的先后次序
											可用正规式描述(其结构)的语言称为正规语言或正规集
											运算的优先级和结合性做下述约定:
												三种运算均具有左结合性质
												优先级从高到底的顺序排列为:闭包运算,连接运算,或运算
												正则表达式中不必要额括号可以被省略
											若正则表达式P和Q表示了同一个正规集,则成PQ是等价的记为P=Q
											正规式的点数性质:r|s=s|r  (rs)t=r(st)
															 r|(s|t)=(r|s)t  εr=rε=r
															 r(s|t)=rs|rt	r*=(r+|ε)
															 (s|t)r=sr|tr	r**=r*
															 简化正规式的描述(主要简化书写上的复杂):正闭包 若r是表示L(r)的正规式 r+表示(L(r))+的正规式,且r+=rr*,r*=r+|ε,+*有相同的运算结合性和优先级
																									可缺省 若r是正规式,r?表示L(r)U{ε} r?=r|ε
																									串	   若r是若干字符进行连接运算构成的正规式,则串'r'=r,ε="", a="a" a是Σ的任意字符
																									字符组 若干字符或运算构成的正规式写成[r']  枚举:a|b|c=[abc],分段:0|1|2|3|a|b|c=[0-3a-e]
																									非字符组 若[r]是一个字符组形成的正规式,[^r]表示 Σ-L([r])的正规式
记号的识别-有限自动机:1:不确定性有限自动机:NonderterministicFiniteAutomaton NFA):NFA是一个五元组(5-tuple):M=(S,Σ,move,s0,F):1:S是有限个状态(state)的集合
																															2:Σ是有限个输入字符包括ε的集合
																															3:move是一个状态转移函数move(si,ch)=sj表示,当前状态si下若遇到输入字符ch,则转移到状态sj
																															4:s0是唯一的初态(开始状态)
																															5:F是终态集(接受状态集)他是S的子集,包含了所有的终态
																				 直观的表示方式:1:状态转换图:用一个有向图来直观表示NFA
																								2:状态转换矩阵:用一个矩阵来直观表示NFA(矩阵中,状态对应行,字符对应列)
																				 NFA(识别记号)的特点:NFA识别记号的最大特点是不确定性,即在当前状态下对同一字符有多于一个的下一状态的转移
																									 具体体现:定义:move函数是1对多的
																											  状态转换图:从同一状态触发,可通过多于一条标记相同字符的边转移到不同的状态
																											  状态转换矩阵:M[si,a]是一个状态的集合
																				 NFA识别记号存在的问题:1:只有尝试了所有可能的路径才能确定一个输入序列不被接受,这些路径的条数随着路径长度的增长呈指数增长
																									   2:识别过程中需要大量回溯,时间复杂度高且算法复杂
					  2:确定的有限自动机(DeterministicFiniteAutomaton DFA):DFA是NFA的一个特例:1:没有转改具有ε状态转移(ε-transition),即状态转换图中没有标记ε的边
																							  2:对每个状态s和每个字符a,最多有一个下一状态
																		   特点:与NFA相比DFA的特征:确定性:定义:move(si,a)函数是1对1的
																											   转换图:从一个状态触发的任意两条边上的标记均不相同
																											   转换矩阵:M[si,a]是一个状态,且字母表不包括ε
正规式和有限自动机从两个侧面表示正规式,正规式是描述,自动机是识别
从正规式到词法分析器:构造此法分析器的一般方法和步骤:1:用正规式描述模式(为记号设计正规式)
													2:为每个正规式构造一个NFA,这一过程也被称为确定化
													3:将构造的NFA转换成等价的DFA这一过程也被称为确定化
													4:优化DFA使其状态树最少,这一过程也被称为最小化
													5:根据优化后的DFA构造词法分析器
					 从正规式到NFA:Thompson算法:正规式,正规集,NFA的对应关系
												正规式		正规集		NFA状态转化图
												1 ε			L(ε)={ε} 	s0..ε->f
												2 a 		L(a)={a}	s0..a->f
												3 P|Q		L(P)UL(Q)	s0..ε->N(P)..ε->f
																		  ..ε->N(Q)..ε->f
												4 PQ		L(P)L(Q) 	s0..ε->N(P)..ε->N(Q)..ε->f
												5 P*		(L(P))*		s0..ε->N(P)..ε->f
																		       <-ε.
																			....ε....->											
					 从NFA到DFA:smove(S,a):从状态集S出发,标记为a的下一状态全体,与move(s,a)的唯一区别:用状态集取代状态							
										   ε-闭包(T):从状态集T出发,不经任何字符达到的状态全体
										   "子集法"构造DFA
					 最小化DFA:1:对于任何两个状态I和S,若从一状态出发接受输入字符串ω,而从另一状态出发不接受ω,
							   2:或者从t出发和从s出发到达不同的接受状态,则称ω状态对t和s是可区分的
							   不可区分的状态位于一个组内,可以合并成一个状态
							   主要步骤:1:初始划分:终态组,非终态组
										2:利用可区分的概念,反复分裂划分中的组Gi,直到不可再分裂
										3:有最终划分构造D',关键是选代表和修改状态转移
										4:消除可能的死状态和不可达状态
	5:从DFA构造词法分析器:分类:		表驱动型的词法分析器,直接编码的词法分析器
					分析器的速度			慢					快
					程序与模式的关系		无关				有关
					适合的编写方法			工具生成			手工编写
					分析器的规模			较大				较小
语法分析:词法分析:记号的集合,字符串有字母组成,线性结构
		 语法分析:句子的集合,句子有记号组成,分线性结构(树)
		 语法分析的双重含义:语法规则:上下文无关文法(子集LL文法或LR文法)
							语法分析:下推自动机(LL或LR分析器),自上而下分析,自下而上分析
		 语法分析的若干问题:语法分析器的作用:根据词法分析器提供的记号流,为语法正确的输入构造分析树(语法树)
											 检查输入中的语法错误(可能包括词法)并调用出错处理器进行适当处理
											 源程序字符流->词法分析器->记号流->语法分析器->分析树->前段其他部分->中间表示
																			   符号表管理器,出错管理器
							语法错误的处理原则:源程序中可能出现的错误:语法(词法)错误和语义错误(静态语义错误和动态语义错误)
											   又可分为静态错误(语法错误,静态语义错误)和动态错误(动态语义错误)
											   词法错误:值非法字符或拼写错关键字标识符等
											   语法错误:指语法结构出错,如少分号,括号不匹配,begin/end不配对
											   静态语义错误:如类型不一致,参数不匹配等
											   动态语义错误(逻辑错误):如死循环,变量为零时做除数等
		 上下文无关文法:Context Free Grammar:CFG是一个四元组G=(N,T,P,S),其中:1:N是非终结符(Nonterminals)的有限集合
																			 2:T是终结符(Terminals)的有限集合,且N/|T=φΦ
																			 3:P是产生式(Productions)的有限集合,A->Αα,其中A<N(左部),a<(N并T)*(右部),若α=ε,则称A->ε为空产生式,A->
																			 4:S是非终结符,称为文法的开始符号(Start symbol)
																			 注:S属N,N可以出现在产生式的左边和右边,T绝对不出现在产生式的左边
											2:CFG产生语言的基本方法:推导:CFG通过推导的方法产生语言,即(通俗的讲)从开始符号S开始,反复使用产生式,将产生式左部的非终结符替换为右部的文法符号序列,展开产生式用=>表示,直到得到一个终结符序列
																	1:直接推导:利用产生式产生句子的过程中,将产生式A->γ的右部代替文法符号序列αAβ得到αγβ的过程,成为直接推导出,记作αAβ=>αγβ
																	2:零步或多不推导,若对于任意文法符号序列,a1,a2..an有a1=>a2=>a3=>..=>an,则此过程成为零步或多步推导,记作a1=*>an,a1=an的情况为零步推导
																	3:至少一次推导:若a1!=an,即推导过程中至少使用一次产生式,则成此过程为至少异步推导,记作:a1=+>an
																	推导具有自反性和传递性
																	4:有CFG所产生的语言L(G)被定义为L(G)={ω|Sω and ω属T*},L(G)被成为上下文无关语言(ContextFreeLanguage,CFL),ω称为是句子,若S=*>a,a属(N并T)*,则成a为G的一个句型,句子一定是句型,反之不是
																	5:在推导过程中,若每次直接推导均替换句型中最左边的非终结符号,则成为最左推导,由最左推导产生的句型称为左句型,类似可以定义最右推导和右句型,最右推导也被称为规范推导
											3:推导,分析树,和语法树:1:分析树既反映语言结构的实质,也反映推导过程						
																   2:对CFGG的句型,分析树被定义为具有下述性质的棵树:1:根有开始符号所标记
																												   2:每个叶子有一个终结符,非终结符或ε标记
																												   3:每个内部节点有一个非终结符标记
																												   4:若A是某内部节点的标记,且X1,X2,X3,...Xn是该节点从左到有所有孩子的标记,记A->X1X2...Xn是一个产生式,若A->ε,则标记为A的节点可以仅有一个标记为ε的孩子
																												   分析树的叶子,从左到右构成G的一个句型,若叶子仅由终结符标记,则构成一个句子
																   3:对CFGG的句型,表达式的语法树被定义为具有下述性质的一棵树:1:根与内部结点由表达式中的操作符标记
																															 2:叶子有表达式中的操作数标记
																															 3:用于改变运算优先级和结合性的括号,被隐含在语法树的机构中
																															 语法树是表示表达式结构的最好形式
																   4:二义性与二义性的消除:二义性:若文法G对同一句子产生不止一棵分析树,则称G是二义的
																						  1:一个句子有多余一棵分析树,仅与文法和句子有关,与采用的推导方法无关
																						  2:造成文法二义的根本原因:文法中缺少对文法符号优先级和结合性的规定
																						  消除的方法:1:改写二义文法为非二义文法
																									 2:规定二义文法中符号的优先级和结合性,使仅产生一棵分析树.
语法和文法简介:0型文法,设G=(N,T,P,S),若他的每个产生式的左边多个字符,至少有一个非终结符,右边有多个字符,是否非终结符不限制,则G是一个0型文法,也称短语文法,0型文法的能力相当于图灵机(Turing)
			   1型文法,也叫上下文有关文法,对应于线性有界自动机,在0型文法的基础上,产生式的左边的字符长度应该小于右边的长度
			   2型文法,同样叫上下文无关文法,对应于下推自动机,在1型文法的基础上满足,产生式的左边的字符都有且只有一个字符,并且是非终结符,
			   3型文法,正规文法,对应于有限状态自动机,在2型文法的基础上,满足右边最多只能有两个字符,一个终结符或者一个非终结符+终结符,在3型文法里,产生式右端的终结符和非终结符的顺序一定是固定的
			   1正规式和上下文无关文法:1:记号可以用正规式描述,正规式适合描述线性结构,如标识符,关键字,注释等
									   2:句子可以用CFG描述,CFG适合描述具有嵌套(层次)性质的非线性结构,如不同结构的句子if-then-else/while-do
									   正规式所描述的语言结构均可以用CFG描述,反之不一定
			   2:上下文有关文法CSG:典型的这类语言结构包括:基数问题的抽象,变量的声明与引用,过程调用时形参与实参的一致性检查等,描述它们的文法成为上下文有关文法(Context Sensitive Grammar),这些语言结构无法用上下文无关文法CSG描述
			   3:形式语言与自动机简介:若文法G=(N,T,P,S)的每个产生式a->b中,均有a数(N并T),且至少含有一个非终结符,b属(N并T),则成G为0型文法
									  对0型文法施加以下限制得到相应的文法:1:G的任何产生式a->b(s->ε除外)满足|a|<=|b|;
																		  2:G的任何产生式形如A->b,其中A属N,b属(N并T)*
																		  3:G的任何产生式形如A->a,或者A->aB(或者A->Ba),其中A和B属N,a属T
自上而下语法分析:递归下降分析法,预测分析法
				 基本思想:对任何一个输入序列w,从S开始进行最左推导,直到得到一个合法的句子或者发现一个非法的结构,整个自上而下分析是一个试探的过程,是反复使用不同的产生式谋求与输入序列匹配的过程.
				 提前准备:重写文法:消除左递归,以避免陷入死循环,2提取左因子,以避免回溯
				 消除左递归:定义:若文法G														 
									  
									 
																	 


















										  